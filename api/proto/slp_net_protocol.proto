// ----------- Изменения добавленные в 11.0.0 -----------
// В 11ой версии протокола реализована работа с модемом.
// - Добавлено устройство SMD.
// - Добавлен новый тип Slp пакета - SmdData.
// ----------- Изменения добавленные в 11.1.0 -----------
// - В enum DeviceType добавлены новые устройства.
// - В сообщение DeviceFirmwareVersion добавлено поле серийного номера.
// - Добавлен slp пакет LbsmData.
// - Добавлен slp пакет LbsmDiagnosticData.
// - Смена порядка в SlpMessage::SlpMessageTypes.
// - В SlpCommand::SlpCommands добавлена новая команда command_13.
// - Добавлен slp пакет NewConfigForLbsm.
// ----------- Изменения добавленные в 11.1.1 -----------
// - Исправлена опечатка в коментарии.
// ----------- Изменения добавленные в 11.1.2 -----------
// - В сообщения LbsmData и LbsmDiagnosticData были добавлены новые поля (RSSI, NOIS и т.д.). 
// ----------- Изменения добавленные в 11.1.3 -----------
// - В enum ResponseToSlpCommand::CommandStatus было добавлено значение err_invalid_command_argument.
// - В enum ServicePacketTypes было добавлено значение Binary.
// - В NewConfigForLbsm::iu_configs введено ограничение на максимальный размер. 
// - Из NewConfigForLbsm::IuConfig убрана тревога. 
// ----------- Изменения добавленные в 11.1.4 -----------
// - Добавлен новый Slp пакет SmdDataDeliveryConfirmation. 
// - В сообщение SmdData добавлено поле package_id.
// ----------- Изменения добавленные в 11.1.5 -----------
// - В сообщения LbsmData::FullSu и LbsmData::ReducedSu добавлено поле su_receiving_time.
syntax = "proto3";
package SlpProtocol;

// Версия протокола.
enum SlpProtocolVersion { v11_1_5 = 0; }

// Типы устройств работающие в системе SLP.(Значение этих перечислений соответствует значениям п2.2 радиопротокола, поэтому изменяя значения здесь необходимо согласовывать эти изменения!).
enum DeviceType {
    empty = 0;          // Пустое значение
    su = 1;             // SU - Subscriber unit(СУ).
    ts = 2;             // TS - Temperature supervisor(УКТ).
    lbs = 3;            // LBS - Local base station(БСМ).
	suf = 4;            // SUF - Subscriber unit fast(АУС).
    smd = 5;            // SMD - Slp modem(МД).
    iu = 6;				// IU - Indoor unit(БВ).
	lbsm = 7;			// LBSM - Local base station modification(БСМ2).
    bs = 8;             // BS - Base station.
    bss = 9;            // BSS - BS которая в данный момент отправлять синхроимпульсы.
}

// ============================================================= Верхний уровень протокола. =============================================================

// Запрос на соединение с сервером.
message ConnectionRequest {
    int32 protocol_version = 1;        // Версия протокола (= 11 для этой версии).
    int32 bs_id = 2;                   // Id базовой станции.
    int32 site_number = 3;             // Номер объекта.
    string bs_app_version = 4;         // Версия текущей прошивки базовой станции.
    bool is_first_launch = 5;          // Флаг того, что приложение было запущено впервые (флаг перезагрузки системы).
    bool is_first_connection = 6;      // Флаг того, что приложение производит своё первое соединение (флаг перезагрузки приложения).
    bool is_starting_from_backup = 7;  // Флаг того, что система запустилась с резервного носителя.
}

// Ответ на запрос на соединение с сервером.
message ConfirmConnection {
    bool connection_confirmed = 1;  // Отверждение соединения или отказ.
    string server_app_version = 2;  // Строковая интерпретация названия версии серверного приложения.
}

// Стандартное сообщение сетевого протокола SLP. На каждый такой пакет от BS сервер должен отправлять подтверждающий пакет SlpMessage::ConfirmingPackage.
message SlpMessage {
    // Типы пакетов протокола SLP.
    enum SlpMessageTypes {
		ConfirmingPackage = 0;              // Пакет подтверждающий приём slp пакета от BS.
		CheckingConnection = 1;             // BS отправляет этот пакет когда, ей необходимо оценить качество соединения с сервером.
        SuData = 2;                         // Данные с конечного устройства.
        SmdData = 3;                        // Данные, связанные с обменом модема slp.
        SmdDataDeliveryConfirmation = 4;    // Подтверждение получения модемом нисходящих данных.
        TelemetryData = 5;                  // Данные телеметрии базовой станции.
		LbsmData = 6;						// Данные от БСМ2.
		LbsmDiagnosticData = 7;				// Диагностические данные от БСМ2.
        BsConfig = 8;                       // Данные с новой конфигурацией BS.
        RadioConfig = 9;                    // Данные с новой конфигурацией радиоканала.
        SlpCommand = 10;                    // Команда системе Slp.
        ResponseToSlpCommand = 11;          // Ответ от BSS на SlpCommand.
        ToCancelSlpCommand = 12;            // Отменить Slp команду на станции.
        ServicePackage = 13;                // Сегмент с сервисным пакетом.
        ServicePackageStatusRequest = 14;   // Запрос состояния сервисного пакета на BS.
        ServicePackageStatusResponse = 15;  // Ответ на запрос состояния сервисного пакета на BS.
        DeviceRegistrationRequest = 16;     // Запрос на регистрацию устройства (тип 1).
        DeviceFirmwareVersion = 17;         // Передача версии прошивки SU.
        ConfirmDeviceRegistration = 18;     // Подтверждение регистрации устройства SLP.
        RemoveServicePackage = 19;          // Удаление сервисного пакета на BS.
        BsCommand = 20;                     // Команда для базовой станции.
        RegisterDeviceInSystem = 21;        // Зарегистрировать устройство в системе.
		NewConfigForLbsm = 22;				// Новая конфигурация для LBSM. Этот пакет меняет настройки LBSM.
    }
    SlpMessageTypes message_type = 2;  // Тип пакета.
    uint32 package_id = 3;             // ID пакета. У каждого пакета свой id который инкрементируется с отправкой каждого пакета.
                                       // Когда это значение становиться == 2^14 - 1 = 16383 то отсчёт снова начинается с нуля.
    bytes data = 4;                    // Payload.
}

// ============================================================== Пакеты различных типов вкладываемые в SlpMessage. ==============================================================

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Данные конечных устройств сети.
// BS -> Server.
// Поле data содержит не распарсенные данные с конечных устройств сети. Эти данные должны парситься по соответствующему
// протоколу устройства. Данные выровнены по 25 байт, первые 22 байта данные пришедшие по радиоканалу, затем два байта rssi устройства (int16) и последний байт это nois (int8).
// Это поле используется, когда распарсить данные на BS не представляется возможным. Поле su_list содержит уже распарсенные ранее данные которые можно забирать как есть.
message SuData {
    bytes data = 1;             // Информация c одного или нескольких устройств которых нет в протоколе (вероятно, новых). По 25 байт. максимум 8 su или 200 байт.
    repeated Su su_list = 2;    // Информация c одного или нескольких SU в десериализованном виде.
    repeated Lbs Lbs_list = 3;  // Информация c одного или нескольких LBS в десериализованном виде.
    repeated Ts Ts_list = 4;    // Информация c одного или нескольких TS в десериализованном виде.
}

// Payload от одного абонентского устройства SLP. В зависимости version некоторые поля будут не валидными (будут иметь нулевые значения).
message Su {
    // Сигналы от акселерометра.
    enum AccelerometerSignal {
        no_any_signals = 0;                 // Сигналов от акселерометра не поступало.
        impact_sensor_was_triggered = 1;    // Сработал датчик удара.
        fall_detector_was_triggered = 2;    // Сработал датчик падения.
        both_detectors_were_triggered = 3;  // Сработали оба датчика.
    }
    // Виды дополнительных сообщений которые может передать устройство в стандартном сообщении(то что порядок сбит это нормально).
    enum AdditionalMessageSu {
        adms_0 = 0;   // Нет дополнительного сообщения.
        adms_1 = 3;   // Была получена команда тревоги от БС.
        adms_2 = 4;   // Получена команда смены прошивки.
        adms_3 = 10;  // Тревога от БС была погашена с кнопки (отправляется в 22 байтном сообщении).
        adms_4 = 11;  // Подтверждение снятия с регистрации устройства.
    }
    // Типы тревог.
    enum AlarmType {
        no_alarm = 0;                  // Отсутствие тревоги.
        triggered_alarm = 1;           // Тревога была подана нажатием кнопки.
        alarm_from_accelerometer = 2;  // Тревога была подана из за показаний акселерометра.
    }
    uint32 id = 1;              // (v1,2,3) Номер устройства.
    uint32 version = 2;         // (Тут задаётся версия) Версия внутреннего протокола устройства.
    uint32 receiving_time = 3;  // (v1,2,3) Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC).
    int32 receiving_rssi = 4;   // (v1,2,3) RSSI замеренное на BS при приёме данных.
    int32 receiving_nois = 5;   // (v1,2,3) Соотношение сигнал-шум замеренный на BS при приёме данных.
    uint32 hour = 6;            // (v1,2,3) Текущее время по гринвичу.
    uint32 minute = 7;
    uint32 second = 8;
    uint32 bat = 9;                       	// (v1,2,3) Уровень заряда батареи в процентах.
    AlarmType alarm = 10;                 	// (v1,2,3) Информация о сигнале тревоги.
    float latitude = 11;                  	// (v1,2,3) Широта.
    float longitude = 12;                 	// (v1,2,3) Долгота.
    float pressure = 13;                  	// (v1,2,3) Атмосферное давление в гектопаскалях.
    uint32 number_satellites = 14;        	// (v1,2,3) Число принимаемых спутников.
    uint32 fix_quality = 15;              	// (v1,2,3) Quality статус GPS\GLONASS приёмника.
    float hdop = 16;                      	// (v2,3) Коэффициент потери точности HDOP (1: ±3м , 99: ±350м).
    uint32 azimuth = 17;                  	// (v2,3) 0÷358 с шагом 2 градуса.
    float speed = 18;                     	// (v2,3) Скорость.
    float temperature = 19;               	// (v2,3) Температура.
    uint32 level_of_motor_activity = 20;  	// (v2,3) Уровень двигательной активности: (0 – 3), 0 – покой
    bool in_room = 21;                    	// (v3) Признак нахождения в помещении.
    uint32 height_change_module = 22; 		// (v3) Максимальное изменения высоты между сеансами связи. Может принимать значения от 0-7.  0 = 0..2.9м, 1 = 3..5.9м, 2 = 6..8.9м, 3 = 9..11.9м, 4 = 12..14.9м, 5 = 15..17.9м, 6 = >18м. Если значение 18 то скорость изменения высоты может быть больше, просто 18 это предел измерения.
    AccelerometerSignal accelerometer_signal = 23;  // (v3) Сигнал от акселерометра SU.
    AdditionalMessageSu additional_message = 24;    // (v3) Дополнительное сообщение которые может передать устройство в стандартном сообщении.
    int32 accelerometer_x = 25;                     // (v1) Ускорение по оси Х.
    int32 accelerometer_y = 26;                     // (v1) Ускорение по оси Y.
    int32 accelerometer_z = 27;                     // (v1) Ускорение по оси Z.
}

// Пакет с данными от одной LBS.
message Lbs {
    // Виды дополнительных сообщений, которые может передать устройство в стандартном сообщении.
    enum AdditionalMessageLbs {
        adml_0 = 0;   // Нет дополнительного сообщения.
        adml_1 = 11;  // Подтверждение снятия с регистрации устройства.
    }
    uint32 id = 1;                                // Номер устройства.
    uint32 receiving_time = 2;                    // Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC).
    int32 receiving_rssi = 3;                     // RSSI замеренное на BS при приёме данных.
    int32 receiving_nois = 4;                     // Уровень шума замеренный на BS при приёме данных.
    int32 threshold_rssi = 5;                     // Порог записи АУ  по rssi  умноженный на минус 1.
    repeated uint32 su_id = 6;                    // Список su устройств которые прошли порог.
    AdditionalMessageLbs additional_message = 7;  // Дополнительное сообщение которые может передать устройство в стандартном сообщении.
}

// Пакет с данными TS.
message Ts {
    // Виды дополнительных сообщений, которые может передать устройство в стандартном сообщении.
    enum AdditionalMessageTs {
        admt_0 = 0;   // Нет дополнительного сообщения.
        admt_1 = 11;  // Подтверждение снятия с регистрации устройства.
    }
    uint32 id = 1;              // Номер устройства.
    uint32 receiving_time = 2;  // Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC).
    int32 receiving_rssi = 3;   // RSSI замеренное на BS при приёме данных.
    int32 receiving_nois = 4;   // Уровень шума замеренный на BS при приёме данных.
    uint32 hour = 5;            // Текущее время по гринвичу.
    uint32 minute = 6;
    uint32 second = 7;
    uint32 bat = 8;                               // Уровень заряда батареи в процентах.
    float latitude = 9;                           // Широта.
    float longitude = 10;                         // Долгота.
    float pressure = 11;                          // Атмосферное давление в гектопаскалях.
    float hdop = 12;                              // Коэффициент потери точности HDOP (1: ±3м , 99: ±350м).
    float temperature = 13;                       // Температура на самом устройстве.
    float temperature_sensor_value_1 = 14;        // Показания температуры первого температурного датчика.
    float temperature_sensor_value_2 = 15;        // Показания температуры второго температурного датчика.
    float temperature_sensor_value_3 = 16;        // Показания температуры третьего температурного датчика.
    float temperature_sensor_value_4 = 17;        // Показания температуры четвёртого температурного датчика.
    AdditionalMessageTs additional_message = 18;  // Дополнительное сообщение которые может передать устройство в стандартном сообщении.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Пакет с телеметрией базовой станции.
// BS -> Server.
message TelemetryData {
    int32 hour = 1;  // Текущее время по гринвичу.
    int32 minute = 2;
    int32 second = 3;
    float latitude = 4;             // Широта
    float longitude = 5;            // Долгота
    int32 fix_quality = 6;          // Текущая фиксация GPS или GLONASS.
    float temperature_inside = 7;   // Температура внутри корпуса.
    float temperature_outside = 8;  // Температура снаружи.
    float pressure = 9;             // Давление в гПа.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Пакет с данными от LBSM (БСМ2).
// BS -> Server.
// По умолчанию LBSM передаёт данные от SU в списке FullSu. Если данных становиться слишком много и LBSM понимает, что не сможет передать все данные на БС в связи с ограничениями 
// радиоканала, то тогда она инициирует передачу данных в сокращённом формате (ReducedSu). 
message LbsmData{
	message IuData { 
		uint32 id = 1;	// Номер IU.
		int32 rssi = 2;	// Уровень сигнала на приёме SU который содержит это сообщение.
		int32 nois = 3;	// Соотношение сигнал-шум на приёме SU который содержит это сообщение.
	}
	message FullSu {
		uint32 id = 1;              			// Номер SU.
		uint32 level_of_motor_activity = 2;  	// Уровень двигательной активности: (0 – 3), 0 – покой
		bool sync_sign = 3; 					// Признак работы по синхросигналу.
		bool alarm = 4;							// Тревога с кнопки. 
		Su.AccelerometerSignal accelerometer_signal = 5; // Сигнал от акселерометра SU.
		float pressure = 6;                  	// Атмосферное давление в гектопаскалях.
		float temperature = 7;               	// Температура.
		uint32 su_receiving_time = 8;  			// Время приёма данных с абонентского устройства, замеренное на внутреннем блоке (миллисекунды прошедшие с начала суток по UTC). Для всех IU одно.
		repeated IuData iu_list = 9;			// Данные с внутренних блоков.
	}
    message ReducedSu {
		uint32 id = 1;              			// Номер SU.
		uint32 su_receiving_time = 2;  			// Время приёма данных с абонентского устройства, замеренное на внутреннем блоке (миллисекунды прошедшие с начала суток по UTC). Для всех IU одно.
		repeated IuData iu_list = 3;			// Данные с внутренних блоков.
	}
	uint32 id = 1;              // Номер Lbsm.
	bool alarm = 2;				// Тревога. Подаётся, когда нет RS-485. 
	uint32 receiving_time = 3;  // Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC).
    int32 receiving_rssi = 4;   // RSSI замеренное на BS при приёме данных.
    int32 receiving_nois = 5;   // Соотношение сигнал-шум замеренный на BS при приёме данных.
	repeated FullSu full_su_list = 6;    	// Полные данные с устройств.
    repeated ReducedSu reduced_su_list = 7; // Сокращённые данные с устройств.
}
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Пакет с диагностическими данными от LBSM (БСМ2).
// BS -> Server.
message LbsmDiagnosticData{
	message IuData {
		uint32 id = 1;				// Номер IU.
		int32 threshold_rssi = 2;	// Порог RSSI.
		int32 threshold_nois = 3;	// Порог по соотношению сигнал-шум.
		bool alarm = 4;				// Тревога.
	}
	uint32 id = 1;              	// Номер Lbsm.
	float temperature = 2;     		// Температура.
	uint32 receiving_time = 3;  	// Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC).
    int32 receiving_rssi = 4;   	// RSSI замеренное на BS при приёме данных.
    int32 receiving_nois = 5;   	// Соотношение сигнал-шум замеренный на BS при приёме данных.
	repeated IuData iu_data = 6;	// Параметры внутренних блоков, которые подключены к LBSM.
}
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Пакет, подтверждающий приём slp пакетов от БС данных. Этот пакет должен отправляться сервером на каждый принятый slp пакет от БС.
// Server -> BS.
message ConfirmingPackage {
    uint32 packet_id = 1;        // ID пакета. У каждого пакета требующего подтверждения свой id который инкрементируется с отправкой каждого пакета.
    bool package_confirmed = 2;  // true - пакет подтверждён; false - пакет требуется отправить повторно.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Данные, связанные с обменом модема slp.
// BS -> Server и Server -> BS.
// Перед тем как работать с какой-либо базовой станцией, модем предварительно регистрируется на ней. В этом случае базовая станция обязательно оповестит об этом сервер послав
// пакет SmdData:: device_was_subscribed. После этого все данные, которые необходимо переслать на этот модем, необходимо отправлять именно на эту БС и только на неё. Если модем
// отписался от БС, то необходимо дождаться, когда он зарегистрируется снова на какой-либо из БС.

message SmdData {
    enum SmdDataType {
        undefined = 0;                  // Неопределённо значение.
        data_from_smd = 1;              // Данные пришедшие с модема. (BS -> Server)
        data_to_smd = 2;                // Данные которые необходимо передать на модем. (Server -> BS)
        device_was_subscribed = 3;      // БС сообщает что данный модем был зарегистрирован на ней. Это означает что все данные, предназначенные для этого модема, сервер должен отправлять на эту БС. (BS -> Server)
        device_was_unsubscribed = 4;  	// БС сообщает что данный модем отписался от этой БС. (BS -> Server)
    }
    SmdDataType packet_type = 1;    // Тип пакета.
    int32 smd_id = 2;            	// Id slp модема.
	int32 package_id = 3; 		    // Id пакета. Это поле заполняется только для типа data_to_smd и нужно для пакета SmdDataDeliveryConfirmation.
    bytes data = 4;                 // Данные с(для) модема. Это поле заполняется только для типов data_from_smd и data_to_smd.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Подтверждение получения модемом нисходящих данных.
// BS -> Server.
// После отправки на БС пакета SmdDataType::data_to_smd сервер должен дождаться подтверждения от БС что данные были переданы на модем. В системе SLP может быть ситуация, когда модем 
// разрывает связь с БС и переключается на другую БС. В этом случае у первой БС нет никакой возможности передать данные. Если сервер получает этот пакет с  data_been_delivered == false 
// то данные необходимо отправить повторно (и скорее всего уже на другую БС).  
message SmdDataDeliveryConfirmation {
    int32 smd_id = 1;            	// Id slp модема.
	int32 package_id = 2; 		    // Id пакета.
    bool data_been_delivered = 3;   // Флаг того, что данные были доставлены. Если == false то сервер должен отправить данные заново (скорее всего на другую БС). 
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Пакет с настройками базовой станции.
// BS -> Server и Server -> BS.
// Если поле нулевое то настраивать это поле не требуется.
message BsConfig {
    enum LoggingLevel {
        logging_undefined = 0;                 // Неопределённо значение.
        logging_disabled = 1;                  // Логирование полностью отключено.
        logging_only_important_anomalies = 2;  // В логи записываются только критические ошибки и важные сообщения (Рекомендуемый режим).
        logging_all_anomalies = 3;             // В логи записываются все отклонения от нормы.
        detailed_logging = 4;  // Подробные логи (рекомендуется включать только в экстренных случаях т.к. этот режим генерирует очень много информации что может привести к быстрому истощению ресурса внешней флэшпамяти).
        detailed_logging_with_deserialization = 5;  // Подробные логи с десериализацией (настоятельно рекомендуется не использовать вообще (этот параметр необходим разработчикам БС)).
    }
    int32 bs_id = 1;                                    // Id базовой станции.
    int32 site_number = 2;                              // Номер объекта. Может быть максимум 255(это ограничение связанно с тем что по радиоканалу на этот параметр отведён один байт)
    bool is_sync_pulse_sending_on = 3;                  // Должна ли станция отправлять синхросигнал (будет она работать в режиме BS или BSS). true - отправлять, false - только слушать эфир.
    uint32 amount_of_servers_used = 4;                  // Количество используемых серверов (1 или 2).
    bytes first_server_ip = 5;                          // Ip адрес первого сервера.
    int32 first_server_port = 6;                        // Порт первого сервера.
    bytes second_server_ip = 7;                         // Ip адрес второго сервера.
    int32 second_server_port = 8;                       // Порт второго сервера.
    int32 period_of_sending_packet_with_telemetry = 9;  // Период (в секундах) отправки телеметрии БС. Через этот промежуток времени БС будет отправлять пакет TelemetryData.
    bool device_autoscaling = 10;                       // Использовать автомаштабирование нумерации устройств или нумерацию с фиксированным каналом.
    float latitude_for_filtering_epd = 11;  // Максимальная разница в градусах по широте между EPD и BS, после которой данные EPD считаются не валидными (в случае фильтрации по координатам), (долгота вычисляется из этого значения).
    LoggingLevel logging_level = 12;        // Уровень логирования станции.
    int32 max_amount_of_log_files = 13;     // Максимальное количество файлов логирования по достижению которого старые файлы удаляются.
    int32 max_size_of_log_file = 14;        // Максимальный размер файла с логами по достижению которого создаётся новый файл.
    bool need_emergency_backup_to_flash = 15;  // Нужно ли сохранять данные с PacketsStorage на внешний флэш-накопитель в случае отключения питания БС (в этом случае, после включения питания данные будут обратно загружены в PacketsStorage).
    int32 emergency_backup_size = 16;  // Количество памяти в мегабайтах которое будет отведено на внешний флэш-накопитель под аварийный дамп с PacketsStorage (в случае переполнения этого объёма самые старые данные выбрасываются).
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// BS -> Server и Server -> BS.
// Данные с новой конфигурацией радиоканала. Если поле нулевое, то настраивать это поле не требуется.
message RadioConfig {
    // Доступные периоды опроса АУ.
    enum PollingPeriod { 
    	p_undefined = 0; 
    	p_duration_30_seconds = 1; 
    	p_duration_60_seconds = 2; 
    	p_duration_2_minutes = 3; 
    	p_duration_3_minutes = 4; 
    	p_duration_5_minutes = 5; 
    }
    // Доступные периоды короткого сна.
    enum ShortSleepDuration { 
    	s_undefined = 0; 
    	s_duration_12_seconds = 1; 
    	s_duration_24_seconds = 2; 
    	s_duration_60_seconds = 3; 
    	s_duration_2_minutes = 4; 
    }
    // Доступные периоды долгого сна.
    enum LongSleepDuration { 
    	l_undefined = 0; 
    	l_duration_2_minutes = 1; 
    	l_duration_10_minutes = 2; 
    	l_duration_30_minutes = 3; 
    	l_duration_1_hour = 4; 
    }
    int32 sync_pulse_power = 1;                       // Мощность синхроимпульса в dBm. Максимум 17.
    int32 su_power = 2;                               // Мощность сигнала всех АУ в dBm. Максимум 17.
    PollingPeriod polling_period = 3;                 // Период опроса всех АУ.
    ShortSleepDuration short_sleep_duration = 4;      // Период короткого сна.
    LongSleepDuration long_sleep_duration = 5;        // Период длинного сна.
    uint32 period_of_the_sync_pulse_in_ms = 6;        // Период синхроимпульса в миллисекундах.
    uint32 size_of_the_sync_pulse_queue_on_site = 7;  // Размер очереди синхроимпульса на объекте.
    uint32 place_in_sync_pulse_queue = 8;             // Место базовой станции в этой очереди.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Команда управления базовой станцией.
// Server -> BS.
message BsCommand {
    enum BaseStationCommands {
        Pass = 0;                 // Пустая команда. Нужна для отладки.
        Reset = 1;                // Перезагрузить БС.
        GetBsSettings = 2;        // Запросить текущие настройки станции.
        GetRadioSettings = 3;     // Запросить текущую конфигурацию радиоканала станции.
        CancelAllSlpCommand = 4;  // Очищает буфер slp команд.
    }
    BaseStationCommands command = 1;  // Команда.
    bytes argument = 2;               // Аргумент команды.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Команда системе Slp.
// Server -> BS.
// Подать Slp команду на соответствующие действия в SLP системе на текущем объекте. Любая команда должна отправляться на все BSS которые находятся на объекте одновременно.
// Если одна из BSS не примет пакет с командой или примет невовремя, то устройства, которые покрываются этой BSS не получат соответствующее воздействие.
// У каждой команды есть свой time_point, опорная точка времени по которой все BSS на объекте отправляют команду синхронно. Это время когда необходимо отправить команду в ms прошедших
// c 1 00:00:00 1970 по UTC. Все станции распределят отправку команд по синхроимпульсам используя этот time_point как отправную точку. Необходимо учитывать, что т.к. минимальное
// время команды 4 периода синхроимпульса (поле period_of_the_sync_pulse_in_ms в радио конфигурации BSS) то минимальное расстояние между двумя time_point должно быть не меньше этого
// времени. Если команда требует отправки нескольких синхроимпульсов, то на всё это время командный канал занимается и time_point необходимо выставлять уже после завершения выполнения
// такой команды. После отправки SlpCommand на все станции каждая станция отправляет ответ ResponseToSlpCommand. Если хоть одна BSS не дала ответ, то рекомендуется отменить команду
// на всех BSS. При отправке команд, которые требует применения дополнительного канала необходимо выбрать master BSS канал которой будет использоваться (BSS с максимальным покрытием
// на объекте или специализированную BSS вокруг которой заранее будут собраны все устройства, например для перепрошивки). На объекте может быть только одна master BSS. Если по
// дополнительному каналу будут передавать сразу несколько BSS то это приведёт к критическим ошибкам в системе.
// В скобочках указан интервал в синхроимпульсах (интервал синхроимпульса это period_of_the_sync_pulse_in_ms, pp это безразмерный PollingPeriod(т.е. не в сек а в разах), N - это количество повторений заданное в аргументе).
message SlpCommand {
    enum SlpCommands {
        command_u = 0;    // (-) Пустое значение.
        command_1 = 1;    // (pp) Запустить передачу EPO (argument_1 - version EPO файлов).
        command_2 = 2;    // (4) Прошить конкретный SU (argument_1 - firmware version; argument_2 - номер SU.).
        command_3 = 3;    // (4) Запрос версии прошивки у SU (argument_1 - номер SU.).
        command_4 = 4;    // (pp * N) Всеобщая тревога (argument_1 - тип тревоги; argument_2 - количество повторений трансляций.).
        command_5 = 5;    // (4) Тревога для конкретного SU (argument_1 - тип тревоги (1 или 2); argument_2 - номер SU.).
        command_6 = 6;    // (4) Перепрошить все TS (argument_1 - версия прошивки TS).
        command_7 = 7;    // (4) Снятие с регистрации SU или TC (argument_1 - номер SU).
        command_8 = 8;    // (pp) Перепрошить все SU со сверкой версии (argument_1 - версия прошивки SU).
        command_9 = 9;    // (pp) Перепрошить все SU без сверки версии (argument_1 - версия прошивки SU).
        command_10 = 10;  // (4) Перепрошить все устройства в определённом кадре и определённом канале (argument_1 - версия прошивки SU; argument_2 - номер кадра + номер канала * 1024.).
        command_11 = 11;  // (4) Смена регистрации у определённого устройства (argument_1 - номер SU).
        command_12 = 12;  // (4) Изменение настроек LBS (argument_1 - номер LBS).
		command_13 = 13;  // (4) Запрос диагностической информации с LBSM (argument_1 - номер LBSM 1-300).

    }
    uint32 id = 1;            // id команды (Инкрементируется в каждой поданной командой. После достижения uint16 обнуляется.)
    SlpCommands type = 2;     // Тип команды.
    uint32 argument_1 = 3;    // Первый аргумент зависящий от типа команды.
    uint32 argument_2 = 4;    // Второй аргумент зависящий от типа команды.
    uint64 time_point = 5;    // Опорная временная точка (смотри описание SlpCommand).
    bool master_station = 6;  // Этот флаг взводится для master BSS (BSS которая отвечает за передачу по дополнительному каналу).
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Ответ от BSS на SlpCommand.
// BS -> Server.
message ResponseToSlpCommand {
    enum CommandStatus {
        unknown_status = 0;                   // Произошло что-то непредвиденное.
        command_is_accepted = 1;              // Команда успешно принята на исполнение.
        err_sync_pulse_already_occupied = 2;  // Текущие синхроимпульсы уже заняты другими командами. Эта ошибка возникает когда неправильно выбран time_point или на станции уже прямо
                                              // сейчас выполняется команда которая требует длительного периода времени на своё выполнение (например перепрошивка устройств или эпох).
        err_not_have_time_to_take_time_point = 3;  // BSS не успела "застолбить" синхроимпульсы соответствующий time_point. Скорее всего time_point быд задан впритык текущему времени.
        err_service_package_unavailable = 4;       // Недоступен сервисный пакет необходимый для этой команды.
        err_i_is_bs = 5;                           // Это станция работающая в режиме BS а не BSS.
        err_time_point_too_far = 6;                // Опорная точка находится слишком далеко в будующем(как правило > 2 суток от текущего времени по UTC).
        err_invalid_command_argument = 7;          // Был задан недопустимый для текущих настроек аргумент команды (например, если команда была подана для 3500 устройства, а текущие настройки poling period подразумевают работу только 3000). 
    }
    uint32 command_id = 1;     // id команды (Инкрементируется в каждой поданной командой. После достижения uint16 обнуляется.)
    CommandStatus status = 2;  // Статус принятой команды.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Отменить Slp команду на станции.
// Server -> BS.
message ToCancelSlpCommand {
    uint32 command_id = 1;  // id команды (Инкрементируется в каждой поданной командой. После достижения uint16 обнуляется.)
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// BS отправляет этот пакет когда, ей необходимо оценить качество соединения с сервером.
// BS -> Server.
message CheckingConnection {}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Сегмент с сервисным пакетом.
// Server -> BS.
// Сервисный пакет, который необходимо залить на станцию (например пакет с эпохами или прошивкой для различных устройств).
message ServicePackage {
    ServicePacketTypes type = 1;
    uint32 version = 2;          // Версия прошивки для Firmware и день в году для EPO (значимыми являются только первые два байта т.е. максимум 65536)
    bytes payload = 3;           // Payload. 4 Kbyte (4096 байт). Последний сегмент может быть меньщего размера.
    uint32 segment_number = 4;   // Номер текущего сегмента пакета (отсчёт начинается с 0).
    uint32 number_of_bytes = 5;  // Количество байт в текущем ServicePackage.
    uint32 crc = 6;              // Crc modbus 16 всего пакета (всех сегментов).
}
// Типы сервисных пакетов.
enum ServicePacketTypes {
    UnknownType = 0;  // Неизвестный(неопределённый) тип.
    Epo = 1;          // Данные EPO.
    SuFirmware = 2;   // Проишвка Su.
    TsFirmware = 3;   // Прошивка Ts.
    Binary = 4;       // Бинарный пакет.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Запрос состояния сервисного пакета на BS.
// Server -> BS.
// Запросить у бс состояние текущего сервисного пакета.
message ServicePackageStatusRequest {
    ServicePacketTypes type = 1;  // Тип сервисного пакета.
    uint32 version = 2;           // Версия прошивки для Firmware и день в году для EPO (значимыми являются только первые два байта т.е. максимум 65536)
    uint32 crc = 3;               // Crc modbus 16 всего пакета (всех сегментов).
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Ответ на запрос состояния сервисного пакета на BS.
// BS -> Server.
// Ответ BS на ServicePackageStatusRequest.
message ServicePackageStatusResponse {
    enum ResponseStatus {
        rs_package_ready = 0;    // Пакет полностью закачен и готов к трансляции.
        package_missing = 1;     // Пакет на BS отсутсвует.
        incomplete_package = 2;  // Пакет закачан не полностью (номера недостающих сегментов перечислены в missing_segments).
        invalid_crc = 3;         // Не совпало CRC пакета.
    }
    ServicePacketTypes type = 1;           // Тип сервисного пакета.
    uint32 version = 2;                    // Версия прошивки для Firmware и день в году для Epo (значимыми являются только первые два байта т.е. максимум 65536)
    ResponseStatus status = 3;             // Ответ.
    repeated uint32 missing_segments = 4;  // Тут перечислены все номера недостающих сегментов сервисного пакета если пакет неполный.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Удаление сервисного пакета на BS.
// Server -> BS.
// Удаление сервисного пакета на BS.
message RemoveServicePackage {
    ServicePacketTypes type = 1;  // Тип сервисного пакета.
    uint32 version = 2;           // Версия прошивки для Firmware и день в году для Epo (значимыми являются только первые два байта т.е. максимум 65536)
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Запрос на регистрацию устройства (тип 1).
// BS -> Server
message DeviceRegistrationRequest {
    uint32 device_id = 1;        // Номер устройства.
    DeviceType device_type = 2;  // Тип устройства
    uint32 serial_number = 3;    // Серийный номер устройства.
    int32 site_number = 4;       // Номер объекта.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Передача версии прошивки устройства SLP (тип 5).
// BS -> Server
message DeviceFirmwareVersion {
    uint32 device_id = 1;         // Номер устройства.
    DeviceType device_type = 2;   // Тип устройства
    uint32 firmware_version = 3;  // Версия прошивки (не более двух байт).
	uint32 serial_number = 4;	  // Серийный номер устройства.
    int32 site_number = 5;        // Номер объекта.
    uint32 hour = 6;              // Текущее время по гринвичу.
    uint32 minute = 7;
    uint32 second = 8;
    uint32 bat = 9;         // Уровень заряда батареи в процентах.
    float temperature = 10;  // Температура.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Потдтверждеине регистрации устройства SLP (тип 6).
// BS -> Server
message ConfirmDeviceRegistration {
    uint32 device_id = 1;        // Номер устройства.
    DeviceType device_type = 2;  // Тип устройства
    uint32 serial_number = 3;    // Серийный номер устройства.
    int32 site_number = 4;       // Номер объекта.
    uint32 hour = 5;             // Текущее время по гринвичу.
    uint32 minute = 6;
    uint32 second = 7;
    uint32 bat = 8;         // Уровень заряда батареи в процентах.
    float temperature = 9;  // Температура.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Зарегистрировать устройство в системе.
// Этот пакет отправляется как ответ на запрос устройства на регистрацию.
// Server -> BS
message RegisterDeviceInSystem {
    enum Status {
        Refusal = 0;                        // Отказ в регистрации.
        Accepted = 1;                       // Дать устройству соответствующие параметры (указанные ниже).
        ResetRegistration = 2;              // Сброс регистрации.
        ManualRegistrationPreparation = 3;  // Подготовка ручной регистрации.
    }
    Status status = 1;
    uint32 device_id = 2;      // Номер устройства.
    uint32 serial_number = 3;  // Серийный номер устройства.
    int32 site_number = 4;     // Номер объекта.
    int32 rssi_threshold = 5;  // Порог rssi (только для LBS).
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Новая конфигурация для LBSM. Этот пакет инициирует перенастройку LBSM и подключённых к ней внутренних блоков.
// ВНИМАНИЕ! В массив iu_configs можно помещать не более 32 IU. Остальные IU будут игнорироваться.  
// Server -> BS
message NewConfigForLbsm {
	message IuConfig {				// Конфигурация для внутреннего блока.
		uint32 id = 1;				// Номер IU.
		int32 threshold_rssi = 2;	// Порог RSSI.
		int32 threshold_nois = 3;	// Порог по соотношению сигнал-шум.
	}
	uint32 id = 1;              		// Номер Lbsm.
	repeated IuConfig iu_configs = 2;	// Конфигурация для конкретного внутреннего блока (IU) подключённого к этой Lbsm. Максимум 32 конфигурации IU.
}





