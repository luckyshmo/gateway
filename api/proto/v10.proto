// SlpProtocol v 10.1.3
// ----------- Изменения добавленные в 10.0.1 -----------
// Убрано из протокола с пометкой "рудимент" означает что эти вещи не были имплементированы или давно не используются, но при этом продолжали оставаться в протоколе для обратной совместимоти парсеров.
// - Поле protocol_version перенесено из SlpMessage в ConnectionRequest. Это позволит добится полной обратной совместимости любых последующих версий с любыми последующими. 	
// - Из ConnectionRequest убрано поле encryption_type (рудимент). 
// - Убран enum EncryptionTypes(рудимент). 
// - В ConfirmConnection добавлено поле server_app_version.
// - В сообщение ConnectionRequest добавлено поле is_starting_from_backup.
// - Поле ServicePacketTypes::Agps переименовано в ServicePacketTypes::Epo(Потому что по факту там Epo, а система A-GPS так и не была реализована).
// - Поле Su::height_change переименовано в Su::height_change_module.
// - Актуализирован состав сообщения BsConfig (убраны старые поля, добавлены новые и т.д.). 
// ----------- Изменения добавленные в 10.1.0 -----------
// - В сообщение Su добавлен enum AccelerometerSignal.
// - В сообщение Su поле acceleration_on_impact заменено на accelerometer_signal.
// - В сообщение BsConfig добавлены поля fixed_latitude и fixed_longitude.
// ----------- Изменения добавленные в 10.1.1 -----------
// - Из сообщения BsConfig убраны поля fixed_latitude и fixed_longitude.
// ----------- Изменения добавленные в 10.1.2 -----------
// - Поправлено описание Su::AdditionalMessageSu::adms_3.
// - Поправлено описание Su::AlarmType::alarm_cleared.
// - Исправлена опечатка BsConfig::max_amount_of_log_file > BsConfig::max_amount_of_log_files.
// ----------- Изменения добавленные в 10.1.3 -----------
// - Из Su::AlarmType убрано значение alarm_cleared.
// - У поля Su::height_change_module изменено описание. 

syntax = "proto3";
package SlpProtocol;

option go_package = "proto/v10";

// Версия протокола
enum SlpProtocolVersion{v10_1_3 = 0;}

// Типы устройств работающие в системе SLP.(Значение этих перечислений соответствует значениям радиопротокола, поэтому изменяя значения здесь необходимо согласовывать эти изменения).
enum DeviceType{
	empty = 0;
	su = 1;		// SU - Subscriber unit.
	ts = 2;		// TS - Temperature supervisor.
	lbs = 3; 	// LBS - Local base station.
	suf = 4; 	// SUF - Subscriber unit fast.
	bs = 5; 	// BS - Base station.
	bss = 6; 	// BSS - BS которая в данный момент отправлять синхроимпульсы.
}

// ============================================================= Верхний уровень протокола. ============================================================= 

// Запрос на соединение с сервером.
message ConnectionRequest{
	int32 protocol_version = 1; // Версия протокола (= 10 для этой версии).
	int32 bs_id = 2;		// Id базовой станции. 
	int32 site_number = 3;	// Номер объекта. 
	string bs_app_version = 4; // Версия текущей прошивки базовой станции. 
	bool is_first_launch = 5;		// Флаг того, что приложение было запущено впервые (флаг перезагрузки системы). 
	bool is_first_connection = 6;	// Флаг того, что приложение производит своё первое соединение (флаг перезагрузки приложения). 
	bool is_starting_from_backup = 7;	// Флаг того, что система запустилась с резервного носителя.  
}

// Ответ на запрос на соединение с сервером.
message ConfirmConnection{
	bool connection_confirmed = 1;	// Отверждение соединения или отказ. 
	string server_app_version = 2;  // Строковая интерпретация названия версии серверного приложения. 
}

// Стандартное сообщение сетевого протокола SLP. На каждый такой пакет от BS сервер должен отправлять подтверждающий пакет SlpMessage::ConfirmingPackage. 
message SlpMessage{
	// Типы пакетов протокола SLP. 
	enum SlpMessageTypes {
		SuData = 0;					// Данные с конечного устройства.
		TelemetryData = 1;			// Данные телеметрии базовой станции.  
		ConfirmingPackage = 2;		// Пакет подтверждающий приём slp пакета от BS.
		BsConfig = 3;				// Данные с новой конфигурацией BS.
		RadioConfig = 4;			// Данные с новой конфигурацией радиоканала. 
		SlpCommand = 5;				// Команда системе Slp. 
		ResponseToSlpCommand = 6;	// Ответ от BSS на SlpCommand. 
		ToCancelSlpCommand = 7;		// Отменить Slp команду на станции. 
		CheckingConnection = 8; 	// BS отправляет этот пакет когда, ей необходимо оценить качество соединения с сервером. 
		ServicePackage = 9;	 		// Сегмент с сервисным пакетом. 
		ServicePackageStatusRequest = 10;	// Запрос состояния сервисного пакета на BS. 
		ServicePackageStatusResponse = 11; 	// Ответ на запрос состояния сервисного пакета на BS. 
		DeviceRegistrationRequest = 12;		// Запрос на регистрацию устройства (тип 1). 
		DeviceFirmwareVersion = 13;       	// Передача версии прошивки SU.
		ConfirmDeviceRegistration = 14;		// Подтверждение регистрации устройства SLP.
		RemoveServicePackage = 15;			// Удаление сервисного пакета на BS. 
		BsCommand = 16;						// Команда для базовой станции. 
		RegisterDeviceInSystem = 17;		// Зарегистрировать устройство в системе. 
	}
    SlpMessageTypes message_type = 2; 	// Тип пакета. 
    uint32 package_id = 3; 				// ID пакета. У каждого пакета свой id который инкрементируется с отправкой каждого пакета. 
										// Когда это значение становиться == 2^14 - 1 = 16383 то отсчёт снова начинается с нуля.
	bytes data = 4;						// Payload.
}

// ============================================================== Пакеты различных типов вкладываемые в SlpMessage. ============================================================== 

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Данные конечных устройств сети. 
// BS -> Server. 
// Поле data содержит не распарсенные данные с конечных устройств сети. Эти данные должны парситься по соответствующему 
// протоколу устройства. Данные выровнены по 25 байт, первые 22 байта данные пришедшие по радиоканалу, затем два байта rssi устройства (int16) и последний байт это nois (int8). 
// Это поле используется, когда распарсить данные на BS не представляется возможным. Поле su_list содержит уже распарсенные ранее данные которые можно забирать как есть.
message SuData {
	bytes data = 1; 			// Информация c одного или нескольких устройств которых нет в протоколе (вероятно, новых). По 25 байт. максимум 8 su или 200 байт.  
	repeated Su su_list = 2;	// Информация c одного или нескольких SU в десериализованном виде. 
	repeated Lbs Lbs_list = 3;	// Информация c одного или нескольких LBS в десериализованном виде. 
	repeated Ts Ts_list = 4;	// Информация c одного или нескольких TS в десериализованном виде. 
}

// Payload от одного абонентского устройства SLP. В зависимости version некоторые поля будут не валидными (будут иметь нулевые значения).  
message Su {
	// Сигналы от акселерометра. 
	enum AccelerometerSignal {
		no_any_signals = 0; 				// Сигналов от акселерометра не поступало.
		impact_sensor_was_triggered = 1;	// Сработал датчик удара.
		fall_detector_was_triggered = 2;	// Сработал датчик падения.
		both_detectors_were_triggered = 3;	// Сработали оба датчика.
	}
	// Виды дополнительных сообщений которые может передать устройство в стандартном сообщении(то что порядок сбит это нормально). 
	enum AdditionalMessageSu{
		adms_0 = 0;		// Нет дополнительного сообщения.
		adms_1 = 3;		// Была получена команда тревоги от БС.
		adms_2 = 4;		// Получена команда смены прошивки.
		adms_3 = 10;	// Тревога от БС была погашена с кнопки (отправляется в 22 байтном сообщении).
		adms_4 = 11;	// Подтверждение снятия с регистрации устройства. 
	}
	// Типы тревог.
	enum AlarmType{
		no_alarm = 0;					// Отсутствие тревоги.
		triggered_alarm = 1;			// Тревога была подана нажатием кнопки.
		alarm_from_accelerometer = 2;	// Тревога была подана из за показаний акселерометра.
	}
	uint32 id = 1;					// (v1,2,3) Номер устройства. 
	uint32 version = 2;				// (Тут задаётся версия) Версия внутреннего протокола устройства. 
	uint32 receiving_time = 3;		// (v1,2,3) Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC). 
	int32 receiving_rssi = 4;		// (v1,2,3) RSSI замеренное на BS при приёме данных. 
    int32 receiving_nois = 5; 		// (v1,2,3) Уровень шума замеренный на BS при приёме данных. 
	uint32 hour = 6;				// (v1,2,3) Текущее время по гринвичу.	
	uint32 minute = 7;
	uint32 second = 8;
	uint32 bat = 9; 				// (v1,2,3) Уровень заряда батареи в процентах.
	AlarmType alarm = 10; 			// (v1,2,3) Информация о сигнале тревоги. 
	float latitude = 11;			// (v1,2,3) Широта. 
	float longitude = 12;			// (v1,2,3) Долгота. 
	float pressure = 13;			// (v1,2,3) Атмосферное давление в гектопаскалях.
	uint32 number_satellites = 14;	// (v1,2,3) Число принимаемых спутников. 
	uint32 fix_quality = 15;		// (v1,2,3) Quality статус GPS\GLONASS приёмника. 
	float hdop = 16; 				// (v2,3) Коэффициент потери точности HDOP (1: ±3м , 99: ±350м).
	uint32 azimuth = 17;			// (v2,3) 0÷358 с шагом 2 градуса.
	float speed = 18;				// (v2,3) Скорость.
	float temperature = 19;			// (v2,3) Температура.
	uint32 level_of_motor_activity = 20;			// (v2,3) Уровень двигательной активности: (0 – 3), 0 – покой
	bool in_room = 21;								// (v3) Признак нахождения в помещении.
	uint32 height_change_module = 22;				// (v3) Максимальное изменения высоты между сеансами связи. Может принимать значения от 0-7.  0 = 0..2.9м, 1 = 3..5.9м, 2 = 6..8.9м, 4 = 9..11.9м, 5 = 12..14.9м, 6 = 15..17.9м, 7 = >18м. Если значение 18 то скорость изменения высоты может быть больше, просто 18 это предел измерения. 
    AccelerometerSignal accelerometer_signal = 23;	// (v3) Сигнал от акселерометра SU. 
	AdditionalMessageSu additional_message = 24;	// (v3) Дополнительное сообщение которые может передать устройство в стандартном сообщении. 
	int32 accelerometer_x = 25;		// (v1) Ускорение по оси Х.
	int32 accelerometer_y = 26;		// (v1) Ускорение по оси Y.
	int32 accelerometer_z = 27;		// (v1) Ускорение по оси Z.
} 

// Пакет с данными от одной LBS. 
message Lbs {
	// Виды дополнительных сообщений, которые может передать устройство в стандартном сообщении. 
	enum AdditionalMessageLbs{
		adml_0 = 0;		// Нет дополнительного сообщения.
		adml_1 = 11;	// Подтверждение снятия с регистрации устройства. 
	}
	uint32 id = 1;					// Номер устройства. 
	uint32 receiving_time = 2;		// Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC). 
	int32 receiving_rssi = 3;		// RSSI замеренное на BS при приёме данных. 
    int32 receiving_nois = 4; 		// Уровень шума замеренный на BS при приёме данных. 
	int32 threshold_rssi = 5;		// Порог записи АУ  по rssi  умноженный на минус 1.
	repeated uint32 su_id = 6;		// Список su устройств которые прошли порог. 
	AdditionalMessageLbs additional_message = 7; // Дополнительное сообщение которые может передать устройство в стандартном сообщении. 
} 

// Пакет с данными TS.
message Ts{
	// Виды дополнительных сообщений, которые может передать устройство в стандартном сообщении. 
	enum AdditionalMessageTs{
		admt_0 = 0;		// Нет дополнительного сообщения.
		admt_1 = 11;	// Подтверждение снятия с регистрации устройства. 
	}
	uint32 id = 1;					// Номер устройства. 
	uint32 receiving_time = 2;		// Время приёма пакета замеренное на БС (миллисекунды прошедшие с начала суток по UTC). 
	int32 receiving_rssi = 3;		// RSSI замеренное на BS при приёме данных. 
    int32 receiving_nois = 4; 		// Уровень шума замеренный на BS при приёме данных. 
	uint32 hour = 5;				// Текущее время по гринвичу.	
	uint32 minute = 6;
	uint32 second = 7;
	uint32 bat = 8; 				// Уровень заряда батареи в процентах.
	float latitude = 9;				// Широта. 
	float longitude = 10;			// Долгота. 
	float pressure = 11;			// Атмосферное давление в гектопаскалях.
	float hdop = 12; 				// Коэффициент потери точности HDOP (1: ±3м , 99: ±350м).
	float temperature = 13;			// Температура на самом устройстве.
	float temperature_sensor_value_1 = 14;	// Показания температуры первого температурного датчика.
	float temperature_sensor_value_2 = 15;	// Показания температуры второго температурного датчика.
	float temperature_sensor_value_3 = 16;	// Показания температуры третьего температурного датчика.
	float temperature_sensor_value_4 = 17;	// Показания температуры четвёртого температурного датчика.
	AdditionalMessageTs additional_message = 18; // Дополнительное сообщение которые может передать устройство в стандартном сообщении. 
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Пакет с телеметрией базовой станции. 
// BS -> Server. 
message TelemetryData{
	int32 hour = 1;					// Текущее время по гринвичу.	
	int32 minute = 2;
	int32 second = 3;
	float latitude = 4;				// Широта 
	float longitude = 5;			// Долгота 
	int32 fix_quality = 6;			// Текущая фиксация GPS или GLONASS.			
	float temperature_inside = 7;	// Температура внутри корпуса.
	float temperature_outside = 8; 	// Температура снаружи.
	float pressure = 9;				// Давление в гПа. 
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Пакет, подтверждающий приём slp пакетов от БС данных. Этот пакет должен отправляться сервером на каждый принятый slp пакет от БС.
// Server -> BS. 
message ConfirmingPackage{
	uint32 packet_id = 1;		// ID пакета. У каждого пакета требующего подтверждения свой id который инкрементируется с отправкой каждого пакета. 
	bool package_confirmed = 2;	// true - пакет подтверждён; false - пакет требуется отправить повторно. 
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Пакет с настройками базовой станции. 
// BS -> Server и Server -> BS. 
// Если поле нулевое то настраивать это поле не требуется.  
message BsConfig {
	enum LoggingLevel{
		logging_undefined = 0;	// Неопределённо значение. 
		logging_disabled = 1;	// Логирование полностью отключено.
		logging_only_important_anomalies = 2;	// В логи записываются только критические ошибки и важные сообщения (Рекомендуемый режим).
		logging_all_anomalies = 3;	// В логи записываются все отклонения от нормы. 
		detailed_logging = 4;		// Подробные логи (рекомендуется включать только в экстренных случаях т.к. этот режим генерирует очень много информации что может привести к быстрому истощению ресурса внешней флэшпамяти). 
		detailed_logging_with_deserialization = 5; // Подробные логи с десериализацией (настоятельно рекомендуется не использовать вообще (этот параметр необходим разработчикам БС)). 
	}
	int32 bs_id = 1;						// Id базовой станции.
	int32 site_number = 2;					// Номер объекта. Может быть максимум 255(это ограничение связанно с тем что по радиоканалу на этот параметр отведён один байт)  
	bool is_sync_pulse_sending_on = 3;		// Должна ли станция отправлять синхросигнал (будет она работать в режиме BS или BSS). true - отправлять, false - только слушать эфир.
	uint32 amount_of_servers_used = 4;		// Количество используемых серверов (1 или 2).
	bytes first_server_ip = 5;				// Ip адрес первого сервера.
	int32 first_server_port = 6;			// Порт первого сервера.
	bytes second_server_ip = 7;				// Ip адрес второго сервера.
	int32 second_server_port = 8;			// Порт второго сервера.
	int32 period_of_sending_packet_with_telemetry = 9;	// Период (в секундах) отправки телеметрии БС. Через этот промежуток времени БС будет отправлять пакет TelemetryData.
  	bool device_autoscaling = 10;				// Использовать автомаштабирование нумерации устройств или нумерацию с фиксированным каналом.  
	float latitude_for_filtering_epd = 11;		// Максимальная разница в градусах по широте между EPD и BS, после которой данные EPD считаются не валидными (в случае фильтрации по координатам), (долгота вычисляется из этого значения).
	LoggingLevel logging_level = 12;			// Уровень логирования станции. 
	int32 max_amount_of_log_files = 13;			// Максимальное количество файлов логирования по достижению которого старые файлы удаляются.
    int32 max_size_of_log_file = 14;			// Максимальный размер файла с логами по достижению которого создаётся новый файл.	
    bool need_emergency_backup_to_flash = 15;	// Нужно ли сохранять данные с PacketsStorage на внешний флэш-накопитель в случае отключения питания БС (в этом случае, после включения питания данные будут обратно загружены в PacketsStorage).
    int32 emergency_backup_size = 16;			// Количество памяти в мегабайтах которое будет отведено на внешний флэш-накопитель под аварийный дамп с PacketsStorage (в случае переполнения этого объёма самые старые данные выбрасываются).
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// BS -> Server и Server -> BS. 
// Данные с новой конфигурацией радиоканала. Если поле нулевое, то настраивать это поле не требуется. 
message RadioConfig {
	// Доступные периоды опроса АУ.
	enum PollingPeriod{
		p_undefined = 0;
		p_duration_30_seconds = 1; 
		p_duration_60_seconds = 2; 
		p_duration_2_minutes = 3; 
		p_duration_3_minutes = 4; 
		p_duration_5_minutes = 5; 
	}
	// Доступные периоды короткого сна.
	enum ShortSleepDuration{
		s_undefined = 0;
		s_duration_12_seconds = 1; 
		s_duration_24_seconds = 2; 
		s_duration_60_seconds = 3; 
		s_duration_2_minutes = 4; 
	}
	// Доступные периоды долгого сна.
	enum LongSleepDuration{
		l_undefined = 0;
		l_duration_2_minutes = 1; 
		l_duration_10_minutes = 2; 
		l_duration_30_minutes = 3; 
		l_duration_1_hour = 4; 
	}
	int32 sync_pulse_power = 1; 			// Мощность синхроимпульса в dBm. Максимум 17.
	int32 su_power = 2; 					// Мощность сигнала всех АУ в dBm. Максимум 17.
	PollingPeriod polling_period = 3; 		// Период опроса всех АУ.
	ShortSleepDuration short_sleep_duration = 4;// Период короткого сна.
	LongSleepDuration long_sleep_duration = 5; 	// Период длинного сна. 
	uint32 period_of_the_sync_pulse_in_ms = 6;			// Период синхроимпульса в миллисекундах.
	uint32 size_of_the_sync_pulse_queue_on_site = 7;	// Размер очереди синхроимпульса на объекте. 
	uint32 place_in_sync_pulse_queue = 8;				// Место базовой станции в этой очереди. 				
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Команда управления базовой станцией.
// Server -> BS. 
message BsCommand{
	enum BaseStationCommands{
		Pass = 0;				// Пустая команда. Нужна для отладки. 
		Reset = 1;				// Перезагрузить БС.
		GetBsSettings = 2;		// Запросить текущие настройки станции.
		GetRadioSettings = 3;	// Запросить текущую конфигурацию радиоканала станции. 
		CancelAllSlpCommand = 4;// Очищает буфер slp команд.
	}
	BaseStationCommands command = 1; // Команда.
	bytes argument = 2; // Аргумент команды.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
// Команда системе Slp.
// Server -> BS. 
// Подать Slp команду на соответствующие действия в SLP системе на текущем объекте. Любая команда должна отправляться на все BSS которые находятся на объекте одновременно.   
// Если одна из BSS не примет пакет с командой или примет невовремя, то устройства, которые покрываются этой BSS не получат соответствующее воздействие.    
// У каждой команды есть свой time_point, опорная точка времени по которой все BSS на объекте отправляют команду синхронно. Это время когда необходимо отправить команду в ms прошедших    
// c 1 00:00:00 1970 по UTC. Все станции распределят отправку команд по синхроимпульсам используя этот time_point как отправную точку. Необходимо учитывать, что т.к. минимальное   
// время команды 4 периода синхроимпульса (поле period_of_the_sync_pulse_in_ms в радио конфигурации BSS) то минимальное расстояние между двумя time_point должно быть не меньше этого    
// времени. Если команда требует отправки нескольких синхроимпульсов, то на всё это время командный канал занимается и time_point необходимо выставлять уже после завершения выполнения  
// такой команды. После отправки SlpCommand на все станции каждая станция отправляет ответ ResponseToSlpCommand. Если хоть одна BSS не дала ответ, то рекомендуется отменить команду   
// на всех BSS. При отправке команд, которые требует применения дополнительного канала необходимо выбрать master BSS канал которой будет использоваться (BSS с максимальным покрытием  
// на объекте или специализированную BSS вокруг которой заранее будут собраны все устройства, например для перепрошивки). На объекте может быть только одна master BSS. Если по  
// дополнительному каналу будут передавать сразу несколько BSS то это приведёт к критическим ошибкам в системе.
// В скобочках указан интервал в синхроимпульсах (интервал синхроимпульса это period_of_the_sync_pulse_in_ms, pp это безразмерный PollingPeriod(т.е. не в сек а в разах), N - это количество повторений заданное в аргументе).  
message SlpCommand{
	enum SlpCommands{
		command_u = 0;  	// (-) Пустое значение.
		command_1 = 1;		// (pp) Запустить передачу EPO (argument_1 - version EPO файлов).
		command_2 = 2;		// (4) Прошить конкретный SU (argument_1 - firmware version; argument_2 - номер SU.).
		command_3 = 3;		// (4) Запрос версии прошивки у SU (argument_1 - номер SU.).
		command_4 = 4;		// (pp * N) Всеобщая тревога (argument_1 - тип тревоги; argument_2 - количество повторений трансляций.).
		command_5 = 5;		// (4) Тревога для конкретного SU (argument_1 - тип тревоги (1 или 2); argument_2 - номер SU.).
		command_6 = 6;		// (4) Перепрошить все TS (argument_1 - версия прошивки TS).
		command_7 = 7;		// (4) Снятие с регистрации SU или TC (argument_1 - номер SU).
		command_8 = 8;		// (pp) Перепрошить все SU со сверкой версии (argument_1 - версия прошивки SU).
		command_9 = 9;		// (pp) Перепрошить все SU без сверки версии (argument_1 - версия прошивки SU).
		command_10 = 10;	// (4) Перепрошить все устройства в определённом кадре и определённом канале (argument_1 - версия прошивки SU; argument_2 - номер кадра + номер канала * 1024.).
		command_11 = 11;	// (4) Смена регистрации у определённого устройства (argument_1 - номер SU).
		command_12 = 12;	// (4) Изменение настроек LBS (argument_1 - номер LBS).
	}
	uint32 id = 1;				// id команды (Инкрементируется в каждой поданной командой. После достижения uint16 обнуляется.) 
	SlpCommands type = 2;		// Тип команды. 
	uint32 argument_1 = 3; 		// Первый аргумент зависящий от типа команды. 
	uint32 argument_2 = 4; 		// Второй аргумент зависящий от типа команды. 
	uint64 time_point = 5;		// Опорная временная точка (смотри описание SlpCommand).
	bool master_station = 6;	// Этот флаг взводится для master BSS (BSS которая отвечает за передачу по дополнительному каналу).
}	

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
// Ответ от BSS на SlpCommand. 
// BS -> Server. 
message ResponseToSlpCommand{
		enum CommandStatus{
			unknown_status = 0;							// Произошло что-то непредвиденное.
			command_is_accepted = 1;					// Команда успешно принята на исполнение. 
			err_sync_pulse_already_occupied = 2; 		// Текущие синхроимпульсы уже заняты другими командами. Эта ошибка возникает когда неправильно выбран time_point или на станции уже прямо
														// сейчас выполняется команда которая требует длительного периода времени на своё выполнение (например перепрошивка устройств или эпох). 
			err_not_have_time_to_take_time_point = 3;	// BSS не успела "застолбить" синхроимпульсы соответствующий time_point. Скорее всего time_point быд задан впритык текущему времени.     
			err_service_package_unavailable = 4;		// Недоступен сервисный пакет необходимый для этой команды. 
			err_i_is_bs = 5;							// Это станция работающая в режиме BS а не BSS.
			err_time_point_too_far = 6;					// Опорная точка находится слишком далеко в будующем(как правило > 2 суток от текущего времени по UTC). 
		}
		uint32 command_id = 1;							// id команды (Инкрементируется в каждой поданной командой. После достижения uint16 обнуляется.) 				
		CommandStatus status = 2; 						// Статус принятой команды.
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
// Отменить Slp команду на станции. 
// Server -> BS. 
message ToCancelSlpCommand{
		uint32 command_id = 1;	// id команды (Инкрементируется в каждой поданной командой. После достижения uint16 обнуляется.) 				
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
// BS отправляет этот пакет когда, ей необходимо оценить качество соединения с сервером. 
// BS -> Server.
message CheckingConnection {					
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Сегмент с сервисным пакетом. 
// Server -> BS. 
// Сервисный пакет, который необходимо залить на станцию (например пакет с эпохами или прошивкой для различных устройств).
message ServicePackage{
	ServicePacketTypes type = 1;
	uint32 version = 2; 	// Версия прошивки для Firmware и день в году для EPO (значимыми являются только первые два байта т.е. максимум 65536)
	bytes payload = 3;		// Payload. 4 Kbyte (4096 байт). Последний сегмент может быть меньщего размера. 
	uint32 segment_number = 4;		// Номер текущего сегмента пакета (отсчёт начинается с 0).
	uint32 number_of_bytes = 5;		// Количество байт в текущем ServicePackage.
	uint32 crc = 6;			// Crc modbus 16 всего пакета (всех сегментов). 
}	
// Типы сервисных пакетов. 
enum ServicePacketTypes{
	UnknownType = 0;		// Неизвестный(неопределённый) тип. 
	Epo = 1;				// Данные EPO. 
	SuFirmware = 2;			// Проишвка Su.
	TsFirmware = 3;			// Прошивка Ts.
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Запрос состояния сервисного пакета на BS. 
// Server -> BS. 
// Запросить у бс состояние текущего сервисного пакета.
message ServicePackageStatusRequest{
	ServicePacketTypes type = 1;	// Тип сервисного пакета.
	uint32 version = 2; 	// Версия прошивки для Firmware и день в году для EPO (значимыми являются только первые два байта т.е. максимум 65536)
	uint32 crc = 3;			// Crc modbus 16 всего пакета (всех сегментов). 
}	

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Ответ на запрос состояния сервисного пакета на BS. 
// BS -> Server. 
// Ответ BS на ServicePackageStatusRequest.
message ServicePackageStatusResponse{
	enum ResponseStatus{
		rs_package_ready = 0;		// Пакет полностью закачен и готов к трансляции. 
		package_missing = 1;		// Пакет на BS отсутсвует.
		incomplete_package = 2;		// Пакет закачан не полностью (номера недостающих сегментов перечислены в missing_segments).
		invalid_crc = 3; 			// Не совпало CRC пакета.
	}
	ServicePacketTypes type = 1;	// Тип сервисного пакета. 	
	uint32 version = 2; 			// Версия прошивки для Firmware и день в году для Epo (значимыми являются только первые два байта т.е. максимум 65536)
	ResponseStatus status = 3;		// Ответ.
	repeated uint32 missing_segments = 4;	// Тут перечислены все номера недостающих сегментов сервисного пакета если пакет неполный. 	
}	

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Удаление сервисного пакета на BS. 
// Server -> BS. 
// Удаление сервисного пакета на BS. 
message RemoveServicePackage{
	ServicePacketTypes type = 1;	// Тип сервисного пакета. 	
	uint32 version = 2; 			// Версия прошивки для Firmware и день в году для Epo (значимыми являются только первые два байта т.е. максимум 65536)
}	

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Запрос на регистрацию устройства (тип 1). 
// BS -> Server
message DeviceRegistrationRequest{
	uint32 device_id = 1;			// Номер устройства.
	DeviceType device_type = 2;		// Тип устройства
	uint32 serial_number = 3;		// Серийный номер устройства. 
	int32 site_number = 4;			// Номер объекта. 
}	

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Передача версии прошивки устройства SLP (тип 5). 
// BS -> Server
message DeviceFirmwareVersion{
	uint32 device_id = 1;			// Номер устройства.
	DeviceType device_type = 2;	// Тип устройства
	uint32 firmware_version = 3;		// Версия прошивки (не более двух байт). 
	int32 site_number = 4;			// Номер объекта. 
	uint32 hour = 5;				// Текущее время по гринвичу.	
	uint32 minute = 6;
	uint32 second = 7;
	uint32 bat = 8; 				// Уровень заряда батареи в процентах.
	float temperature = 9;			// Температура.
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Потдтверждеине регистрации устройства SLP (тип 6). 
// BS -> Server
message ConfirmDeviceRegistration{
	uint32 device_id = 1;			// Номер устройства.
	DeviceType device_type = 2;	// Тип устройства
	uint32 serial_number = 3;		// Серийный номер устройства. 
	int32 site_number = 4;			// Номер объекта. 
	uint32 hour = 5;				// Текущее время по гринвичу.	
	uint32 minute = 6;
	uint32 second = 7;
	uint32 bat = 8; 				// Уровень заряда батареи в процентах.
	float temperature = 9;			// Температура.
}

// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
// Зарегистрировать устройство в системе. 
// Этот пакет отправляется как ответ на запрос устройства на регистрацию. 
// Server -> BS
message RegisterDeviceInSystem{
	enum Status{
        Refusal = 0;    // Отказ в регистрации.  
        Accepted = 1;    // Дать устройству соответствующие параметры (указанные ниже). 
        ResetRegistration = 2;                // Сброс регистрации. 
        ManualRegistrationPreparation = 3;    // Подготовка ручной регистрации.   
	}
	Status status = 1;
	uint32 device_id = 2;			// Номер устройства.
	uint32 serial_number = 3;		// Серийный номер устройства. 
	int32 site_number = 4;			// Номер объекта. 
	int32 rssi_threshold = 5;		// Порог rssi (только для LBS).
}

